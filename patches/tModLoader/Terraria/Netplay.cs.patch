--- src/Terraria/Terraria/Netplay.cs
+++ src/tModLoader/Terraria/Netplay.cs
@@ -1,4 +_,5 @@
 using System;
+using System.Collections.Concurrent;
 using System.IO;
 using System.Linq;
 using System.Net;
@@ -7,10 +_,12 @@
 using System.Runtime.CompilerServices;
 #endif
 using System.Threading;
+using System.Threading.Tasks;
 using Terraria.Audio;
 using Terraria.IO;
 using Terraria.Localization;
 using Terraria.Map;
+using Terraria.ModLoader;
 using Terraria.Net;
 using Terraria.Net.Sockets;
 using Terraria.Social;
@@ -21,7 +_,6 @@
 #if SERVER && WINDOWS
 using NATUPNPLib;
 #endif
-
 namespace Terraria
 {
 	public class Netplay
@@ -82,6 +_,7 @@
 
 		private static void ResetNetDiag() {
 			Main.ActiveNetDiagnosticsUI.Reset();
+			ModNet.ResetNetDiag();
 		}
 
 		public static void ResetSections() {
@@ -121,6 +_,19 @@
 			return false;
 		}
 
+		private static readonly ConcurrentQueue<Task> mainThreadTasks = new ConcurrentQueue<Task>();
+
+		internal static void OnUpdate() {
+			while (mainThreadTasks.TryDequeue(out Task t))
+				t.RunSynchronously();
+		}
+
+		private static void InvokeOnMainThread(Action action) {
+			var t = new Task(action);
+			mainThreadTasks.Enqueue(t);
+			t.Wait();
+		}
+
 		private static void OpenPort(int port) {
 #if SERVER && WINDOWS
 			string localIPAddress = GetLocalIPAddress();
@@ -421,6 +_,7 @@
 		}
 
 		private static void ClientLoopSetup(RemoteAddress address) {
+			Logging.Terraria.InfoFormat("Connecting to {0}", address.GetFriendlyName());
 			ResetNetDiag();
 			Main.ServerSideCharacter = false;
 			if (Main.rand == null)
@@ -440,9 +_,11 @@
 
 			Disconnect = false;
 			Connection = new RemoteServer();
-			Connection.ReadBuffer = new byte[1024];
+			Connection.ReadBuffer = new byte[ushort.MaxValue];
 		}
 
+
+		internal static bool syncingWorld = false;
 		private static void InnerClientLoop() {
 			try {
 				NetMessage.buffer[256].Reset();
@@ -485,6 +_,7 @@
 						else if (Connection.State == 5 && WorldGen.worldCleared) {
 							Connection.State = 6;
 							Main.player[Main.myPlayer].FindSpawn();
+							syncingWorld = true;
 							NetMessage.SendData(8, -1, -1, null, Main.player[Main.myPlayer].SpawnX, Main.player[Main.myPlayer].SpawnY);
 						}
 
@@ -507,8 +_,6 @@
 								Main.statusText = Connection.StatusText + ": " + (int)((float)Connection.StatusCount / (float)Connection.StatusMax * 100f) + "%";
 							}
 						}
-
-						Thread.Sleep(1);
 					}
 					else if (Connection.IsActive) {
 						Main.statusText = Language.GetTextValue("Net.LostConnection");
@@ -518,6 +_,7 @@
 					num = Connection.State;
 				}
 
+				syncingWorld = false;
 				try {
 					Connection.Socket.Close();
 				}
@@ -688,6 +_,9 @@
 		public static int GetSectionX(int x) => x / 200;
 		public static int GetSectionY(int y) => y / 150;
 
+		// Could use a CancellationToken here but... it's literally one private instance. I don't mind. Less work.
+		private static bool abortBroadcastThread;
+
 		private static void BroadcastThread() {
 			BroadcastClient = new UdpClient();
 			new IPEndPoint(IPAddress.Any, 0);
@@ -711,7 +_,7 @@
 				}
 			}
 
-			while (true) {
+			while (!abortBroadcastThread) {
 				int num = 0;
 				for (int i = 0; i < 255; i++) {
 					if (Main.player[i].active)
@@ -729,6 +_,8 @@
 
 				Thread.Sleep(1000);
 			}
+
+			broadcastThread = null;
 		}
 
 		public static void StartBroadCasting() {
@@ -741,8 +_,9 @@
 
 		public static void StopBroadCasting() {
 			if (broadcastThread != null) {
-				broadcastThread.Abort();
-				broadcastThread = null;
+				abortBroadcastThread = true;
+				// Signal the thread to kill itself, but don't kill it ourselves.
+				// This avoids .NET Core complaining about an unsupported operation bleh. This is also very manipulative and borderline psychopathic
 			}
 
 			if (BroadcastClient != null) {
