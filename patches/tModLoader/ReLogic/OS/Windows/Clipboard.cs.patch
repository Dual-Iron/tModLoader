--- src/Terraria/ReLogic/OS/Windows/Clipboard.cs
+++ src/tModLoader/ReLogic/OS/Windows/Clipboard.cs
@@ -1,18 +_,20 @@
 using ReLogic.OS.Base;
 using System;
+using System.ComponentModel;
+using System.Runtime.InteropServices;
+using System.Text;
 using System.Threading;
-using System.Windows.Forms;
 
 namespace ReLogic.OS.Windows
 {
 	internal class Clipboard : ReLogic.OS.Base.Clipboard
 	{
-		protected override string GetClipboard() => InvokeInStaThread(() => System.Windows.Forms.Clipboard.GetText());
+		protected override string GetClipboard() => InvokeInStaThread(() => WinClip.Get());
 
 		protected override void SetClipboard(string text) {
 			if (!string.IsNullOrEmpty(text)) {
 				InvokeInStaThread(delegate {
-					System.Windows.Forms.Clipboard.SetText(text);
+					WinClip.Set(text);
 				});
 			}
 		}
@@ -55,5 +_,139 @@
 				return ApartmentState.MTA;
 			}
 		}
+	}
+
+	// https://github.com/CopyText/TextCopy
+	// WindowsClipboard.cs
+
+	internal static class WinClip
+	{
+		public static void Set(string text) {
+			TryOpenClipboard();
+			EmptyClipboard();
+			IntPtr hGlobal = default;
+			try {
+				var bytes = (text.Length + 1) * 2;
+				hGlobal = Marshal.AllocHGlobal(bytes);
+
+				if (hGlobal == default) {
+					ThrowWin32();
+				}
+
+				var target = GlobalLock(hGlobal);
+
+				if (target == default) {
+					ThrowWin32();
+				}
+
+				try {
+					Marshal.Copy(text.ToCharArray(), 0, target, text.Length);
+				}
+				finally {
+					GlobalUnlock(target);
+				}
+
+				if (SetClipboardData(cfUnicodeText, hGlobal) == default) {
+					ThrowWin32();
+				}
+
+				hGlobal = default;
+			}
+			finally {
+				if (hGlobal != default) {
+					Marshal.FreeHGlobal(hGlobal);
+				}
+
+				CloseClipboard();
+			}
+		}
+
+		public static string Get() {
+			if (!IsClipboardFormatAvailable(cfUnicodeText)) {
+				return null;
+			}
+			TryOpenClipboard();
+
+			IntPtr handle = default;
+
+			IntPtr pointer = default;
+			try {
+				handle = GetClipboardData(cfUnicodeText);
+				if (handle == default) {
+					return null;
+				}
+
+				pointer = GlobalLock(handle);
+				if (pointer == default) {
+					return null;
+				}
+
+				var size = GlobalSize(handle);
+				var buff = new byte[size];
+
+				Marshal.Copy(pointer, buff, 0, size);
+
+				return Encoding.Unicode.GetString(buff).TrimEnd('\0');
+			}
+			finally {
+				if (pointer != default) {
+					GlobalUnlock(handle);
+				}
+
+				CloseClipboard();
+			}
+		}
+
+		private static void TryOpenClipboard() {
+			var num = 10;
+			while (true) {
+				if (OpenClipboard(default)) {
+					break;
+				}
+
+				if (--num == 0) {
+					ThrowWin32();
+				}
+
+				Thread.Sleep(100);
+			}
+		}
+
+		private const uint cfUnicodeText = 13;
+
+		private static void ThrowWin32() {
+			throw new Win32Exception(Marshal.GetLastWin32Error());
+		}
+
+		[DllImport("User32.dll", SetLastError = true)]
+		[return: MarshalAs(UnmanagedType.Bool)]
+		private static extern bool IsClipboardFormatAvailable(uint format);
+
+		[DllImport("User32.dll", SetLastError = true)]
+		private static extern IntPtr GetClipboardData(uint uFormat);
+
+		[DllImport("kernel32.dll", SetLastError = true)]
+		private static extern IntPtr GlobalLock(IntPtr hMem);
+
+		[DllImport("kernel32.dll", SetLastError = true)]
+		[return: MarshalAs(UnmanagedType.Bool)]
+		private static extern bool GlobalUnlock(IntPtr hMem);
+
+		[DllImport("user32.dll", SetLastError = true)]
+		[return: MarshalAs(UnmanagedType.Bool)]
+		private static extern bool OpenClipboard(IntPtr hWndNewOwner);
+
+		[DllImport("user32.dll", SetLastError = true)]
+		[return: MarshalAs(UnmanagedType.Bool)]
+		private static extern bool CloseClipboard();
+
+		[DllImport("user32.dll", SetLastError = true)]
+		private static extern IntPtr SetClipboardData(uint uFormat, IntPtr data);
+
+		[DllImport("user32.dll")]
+		private static extern bool EmptyClipboard();
+
+		[DllImport("Kernel32.dll", SetLastError = true)]
+		private static extern int GlobalSize(IntPtr hMem);
 	}
 }
